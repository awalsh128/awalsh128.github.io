<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.20.2 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>C++ Memory Semantics for C# and Java Devs - Andrew Walsh’s Website</title>
<meta name="description" content="Understanding how memory semantics works in C++ from the perspective of a C# or Java dev.">


  <meta name="author" content="Andrew Walsh">
  
  <meta property="article:author" content="Andrew Walsh">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Andrew Walsh's Website">
<meta property="og:title" content="C++ Memory Semantics for C# and Java Devs">
<meta property="og:url" content="http://localhost:4000/cpp-memory-semantic-for-csharp-java-devs/">


  <meta property="og:description" content="Understanding how memory semantics works in C++ from the perspective of a C# or Java dev.">







  <meta property="article:published_time" content="2020-10-15T00:00:00-07:00">





  

  


<link rel="canonical" href="http://localhost:4000/cpp-memory-semantic-for-csharp-java-devs/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Andrew Walsh",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Andrew Walsh's Website Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Andrew Walsh's Website
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/reading/">Reading</a>
            </li><li class="masthead__menu-item">
              <a href="/notes">Notes</a>
            </li><li class="masthead__menu-item">
              <a href="/posts/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/img/avatar_lowres.png" alt="Andrew Walsh" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Andrew Walsh</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Coder with a passion for data privacy.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">US</span>
        </li>
      

      
        
          
            <li><a href="https://github.com/awalsh128" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
            <li><a href="https://www.linkedin.com/in/andrew-walsh-a235787/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">Linkedin</span></a></li>
          
        
      

      

      
        <li>
          <a href="mailto:awalsh128@gmail.com">
            <meta itemprop="email" content="awalsh128@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="C++ Memory Semantics for C# and Java Devs">
    <meta itemprop="description" content="Understanding how memory semantics works in C++ from the perspective of a C# or Java dev.">
    <meta itemprop="datePublished" content="2020-10-15T00:00:00-07:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">C++ Memory Semantics for C# and Java Devs
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          15 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-columns"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#the-literal-approach-aka-wrong-approach">The Literal Approach (AKA Wrong Approach)</a></li>
  <li><a href="#storage-duration">Storage Duration</a>
    <ul>
      <li><a href="#automatic">Automatic</a></li>
      <li><a href="#dynamic">Dynamic</a></li>
      <li><a href="#thread">Thread</a></li>
      <li><a href="#static">Static</a></li>
    </ul>
  </li>
  <li><a href="#types">Types</a>
    <ul>
      <li><a href="#fundamental-types">Fundamental Types</a></li>
      <li><a href="#objects">Objects</a></li>
      <li><a href="#references--pointers">References &amp; Pointers</a></li>
      <li><a href="#smart-pointers">Smart Pointers</a>
        <ul>
          <li><a href="#unique-pointer">Unique Pointer</a></li>
          <li><a href="#shared-pointer">Shared Pointer</a></li>
          <li><a href="#weak-pointer">Weak Pointer</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#examples">Examples</a>
    <ul>
      <li><a href="#inputs">Inputs</a></li>
      <li><a href="#outputs">Outputs</a>
        <ul>
          <li><a href="#outputs-as-return-value">Outputs as Return Value</a></li>
          <li><a href="#outputs-as-arguments">Outputs as Arguments</a></li>
          <li><a href="#readability">Readability</a></li>
        </ul>
      </li>
      <li><a href="#dependency-injection-di-container">Dependency Injection (DI) Container</a></li>
    </ul>
  </li>
  <li><a href="#rules-of-thumb">Rules of Thumb</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

            </nav>
          </aside>
        
        <p>When I first started using C++, I was really confused as to how to pass things around and reason about best practices for memory. In C#, primitives were passed by value and all else by memory reference (ignoring nuance). C++ was a whole new world of aliases, pointers, smart pointers, [r/l]value references, forwarding, moves, etc.</p>

<p>This post is a simplified approach to helping C# and Java devs get an introductory understanding of C++ memory semantics so they can confidently create signatures correctly and use it as a stepping stone for more advances techniques. In the following post we will compare C++ against C# for simplicity so we don’t have to constantly bring up both C# and Java.</p>

<p>The layout of this post will follow:</p>
<ul>
  <li>An example of a non-idiomatic approach to C++ and show why it is inefficient.</li>
  <li>Define the storage durations so that we can understand how C++ handles objects in memory.</li>
  <li>Define the types used to communicate the memory semantics involved.</li>
  <li>Walk through examples, styles and use of the different types described.</li>
</ul>

<div class="alert alert-warning notice--warning" role="alert"><i class="fa fa-exclamation-triangle"></i> <b>WARNING:</b> We will tend to generalize ideas and lack preciseness in some areas. This is intentional to keep the reader on track. For example, I will not point out memory nuance, or undefined behavior treatments from different compilers. Also, it is assumed that you already understand what pointers, const and references are.</div>

<h2 id="the-literal-approach-aka-wrong-approach">The Literal Approach (AKA Wrong Approach)</h2>

<p>Let’s start with a common misconception. Memory semantics and how the language approaches it are important. We can’t just take our understanding from C# and literally apply it to C++.</p>

<p>For example:</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Object</span> <span class="p">{</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">o</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Object</span><span class="p">();</span>
<span class="nf">Foo</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
</code></pre></div></div>

<p>Could literally be transformed into:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Object</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">Object</span><span class="o">*</span> <span class="n">o</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span><span class="o">*</span> <span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is a terrible idea, don’t do this. The main mistake is confusing C# class memory semantics with C++’s.</p>
<ul>
  <li>You just can’t change the C# reference to a C++ pointer and be done. This go against the C++ philosophy to prefer the stack. Especially since this is an option not available in C# due to the division between value and reference types</li>
  <li><code class="language-plaintext highlighter-rouge">Object</code> is very small (about 8 bytes) and is best allocated on the stack since it is faster (see <a href="http://www.gotw.ca/gotw/009.htm">gotw/009</a>).</li>
  <li>The scope of the <code class="language-plaintext highlighter-rouge">Object</code> instance isn’t well defined but if we assume it is short lived there is no need for <a href="https://en.cppreference.com/w/cpp/language/storage_duration">dynamic allocation</a>.</li>
</ul>

<p>Here is a better way to do it:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Object</span> <span class="n">o</span><span class="p">;</span>
<span class="n">FooReadOnly</span><span class="p">(</span><span class="n">o</span><span class="p">);</span> <span class="c1">// Simple and fast copy.</span>
<span class="n">FooWrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="p">);</span>   <span class="c1">// Simple and fast copy of stack address pointer.</span>
</code></pre></div></div>

<h2 id="storage-duration">Storage Duration</h2>

<p>As noted, there is a strong preference to allocate on the stack since it is much faster for small objects. In C# it is generally assumed that fundamental types are allocated on the stack and reference types on the heap. This is optional in the C++ language as the developer can decide to allocate classes on the stack or on the heap. Therefore it is helpful for the new developer to understand how <a href="https://en.cppreference.com/w/cpp/language/storage_duration">storage duration / lifetime</a> works in C++.</p>

<p>Going forward we will refer to allocation in terms of the storage duration. Concepts like stack and heap are implementation concerns. While useful when first learning these durations it is better to speak in terms of the traits of these durations than the lower level understanding. For example stack storage is fast but we might as well just say automatic storage is fast instead.</p>

<h3 id="automatic">Automatic</h3>

<p>The object lifetime is tied to the code block it is allocated in and is deallocated at the end of the block. We should aim to use this storage duration whenever possible. As noted previously, it is faster (see <a href="http://www.gotw.ca/gotw/009.htm">gotw/009</a>)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Object is allocated.</span>
  <span class="c1">// ...</span>
<span class="p">}</span>             <span class="c1">// Object is deallocated.</span>
</code></pre></div></div>

<h3 id="dynamic">Dynamic</h3>

<p>The object lifetime is tied to the declaration of an instance and the explicit deallocation of the instance (<a href="http://www.cplusplus.com/doc/tutorial/dynamic/">see examples</a>).</p>

<div class="alert alert-warning notice--warning" role="alert"><i class="fa fa-exclamation-triangle"></i> <b>WARNING:</b> Missed deallocation can results in Out of Memory (OOM) errors. This is one of the most dangerous durations since the [de]allocation is controlled by the dev.</div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">Object</span><span class="o">*</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span><span class="o">*</span> <span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="k">delete</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="thread">Thread</h3>

<p>The object lifetime is tied to the thread allocation and deallocation. In the example below we will not consider race conditions.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;threads&gt;
</span>
<span class="c1">// Object is statically allocated. See Static section below for more information.</span>
<span class="k">thread_local</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// x is allocated on the thread with original declared value for every new thread and </span>
  <span class="c1">// incremented.</span>
  <span class="n">x</span> <span class="o">+=</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>   <span class="c1">// Thread instance of x becomes 3 inside Foo.</span>
  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>   <span class="c1">// Thread instance of x becomes 4 inside Foo.</span>

  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// Thread instance of x is deallocated once thread joins and deallocates.</span>
  <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="static">Static</h3>

<p>The object lifetime is tied to that of the program. Note the <code class="language-plaintext highlighter-rouge">thread_local</code> declaration in the section above has static storage duration. Try to be sparing with the size and use of these objects since they have the largest lifetime.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// x is allocated at program start and deallocated at program end.</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">++</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Foo</span><span class="p">();</span>  <span class="c1">// x is incremented; x = 2.</span>
<span class="n">Foo</span><span class="p">();</span>  <span class="c1">// x is incremented; x = 3.</span>
</code></pre></div></div>

<p>An example of static local variables.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="o">++</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Foo</span><span class="p">();</span>  <span class="c1">// y is initialized; y = 1. From now on, the declaration is skipped.</span>
<span class="n">Foo</span><span class="p">();</span>  <span class="c1">// y declaration is skipped and incremented; y = 2;</span>
<span class="n">Foo</span><span class="p">();</span>  <span class="c1">// y declaration is skipped and incremented; y = 3;</span>
</code></pre></div></div>

<h2 id="types">Types</h2>

<p>C# has a single type taxonomy where everything is derived / inherited from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object?view=netcore-3.1#remarks">Object</a> (example <a href="https://docs.microsoft.com/en-us/dotnet/api/system.int64"><code class="language-plaintext highlighter-rouge">Int64</code></a>). This taxonomy allows a common interface of methods available to all child objects like <code class="language-plaintext highlighter-rouge">Equals</code> and <code class="language-plaintext highlighter-rouge">ToString</code>. This is not the case for C++. It uses <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> to resolve an operations validity at compile time. If the operands have the needed operation (e.g. equals) then it is considered valid.</p>

<h3 id="fundamental-types">Fundamental Types</h3>

<p><a href="https://en.cppreference.com/w/cpp/language/types">C++ fundamental types</a> are the same types as found in <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types">C# value types</a>.</p>

<h3 id="objects">Objects</h3>

<p><a href="https://en.cppreference.com/w/cpp/language/object">Objects</a> also encompass fundamental types as well as classes and structs. Without any additional modifiers, objects are automatically allocated.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Make a automatic copy and use inside Foo.</span>
<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">// In terms of memory it is the same as Foo(int x) since x will be passed as a copy.</span>
<span class="c1">// The only reason to keep as const would be to avoid modification inside the code block. </span>
<span class="c1">// IMO, this is indicative of a leaky interface since it is implementation specific.</span>
<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>            <span class="c1">// ERROR: Cannot change a constant value.</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>        <span class="c1">// Make a copy of x and assign to y; x = 1, y = 1.</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// Make a copy of x and assign to z upon its initialization.</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="references--pointers">References &amp; Pointers</h3>

<div class="alert alert-warning notice--warning" role="alert"><i class="fa fa-exclamation-triangle"></i> <b>WARNING:</b> Don’t confuse C# reference types with C++ references. In computer science it is defined as a <a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">value that indirectly accesses a particular datum</a>. C++ narrows this definition to a <a href="https://en.wikipedia.org/wiki/Reference_(C%2B%2B)">specific datatype implementation</a> using the <code class="language-plaintext highlighter-rouge">&amp;</code> operator, whereas the general definition could refer to pointers as well.</div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// Make a copy of x and assign to y; x = 1, y = 1</span>

  <span class="kt">int</span><span class="o">*</span> <span class="n">z</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
  <span class="o">*</span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>     <span class="c1">// Reference x from z; x = 2</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>  <span class="c1">// ERROR: Cannot get a reference from a const value.</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>   <span class="c1">// x = 2</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Equivalent function but using a pointer.</span>
<span class="kt">void</span> <span class="nf">Quux</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Quux</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="c1">// x is now 2;</span>
</code></pre></div></div>

<p>Sharing a read only reference.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LargeObject</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">LargeObject</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="o">:</span> <span class="cm">/*...*/</span><span class="p">{};</span>

  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="c1">// Lots of members of large size.</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">LargeObject</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Read only and use data from o.</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">LargeObject</span> <span class="n">o</span><span class="p">(...);</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">LargeObject</code> is specified for the sake of needing dynamic allocation. This can be due to: having a container with an unspecified size, lifetime is managed in threads, or is in a larger scope than the immediate function and dependent functions.</p>

<h3 id="smart-pointers">Smart Pointers</h3>

<p>Resource Acquisition Is Initialization (<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a>) is a language idiom that essentially says that object creation is undone by destruction. In C++ this means that any object construction on the stack is also destructed when the object falls out of scope. Smart pointers are simply a wrapper around a pointer. It is allocated when the smart pointer is allocated and deallocated when the smart pointer is deallocated (see <a href="https://en.cppreference.com/w/cpp/language/raii">Resource Acquisition Is Initialization (RAII)</a>. This gets rid of the need to explicitely call a delete and ties the resource lifetime to that of the object wrapping it.</p>

<p>Smart pointers have most of the common operations you would expect like <code class="language-plaintext highlighter-rouge">*x</code> and <code class="language-plaintext highlighter-rouge">x-&gt;y</code>.</p>

<p>A crude way to represent this, ignoring operations, would be:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">simple_smart_pointer</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">simple_smart_pointer</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="c1">// Don't allow copies or multiple assignments.</span>
  <span class="c1">// There should only ever be a single instance.</span>
  <span class="n">simple_smart_pointer</span><span class="p">(</span><span class="k">const</span> <span class="n">simple_smart_pointer</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">simple_smart_pointer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">simple_smart_pointer</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">TArgs</span><span class="p">&gt;</span>
  <span class="k">explicit</span> <span class="n">simple_smart_pointer</span><span class="p">(...</span><span class="n">args</span><span class="p">)</span>  <span class="c1">// Pass variadic args.</span>
  <span class="p">{</span>
    <span class="n">value_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">simple_smart_pointer</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">delete</span> <span class="n">value_</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="unique-pointer">Unique Pointer</h4>

<p>An example of using a type of non-shared smart pointer called <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code class="language-plaintext highlighter-rouge">std::unique_ptr</code></a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;memory&gt;
</span>
<span class="k">class</span> <span class="nc">LargeObject</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">LargeObject</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="o">:</span> <span class="cm">/* initialize members */</span> <span class="p">{};</span>

  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="c1">// Lots of members of large size.</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LargeObect</span><span class="o">&gt;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Take ownership and process o.</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Automatically allocate std::unique_ptr and dynamically allocate the wrapped value.</span>
  <span class="k">auto</span> <span class="n">o</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LargeObject</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
  <span class="c1">// ...</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">o</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <a href="https://en.cppreference.com/w/cpp/utility/move">std::move</a> function is used to transfer the resource from <code class="language-plaintext highlighter-rouge">Bar</code> scope to <code class="language-plaintext highlighter-rouge">Foo</code>. This means that ownership can be passed to other scopes and objects. Although once moved, it can no longer be used in that same scope.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;memory&gt;
</span>
<span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LargeObject</span><span class="o">&gt;</span> <span class="n">o</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">o</span><span class="p">));</span>  
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">;</span>   <span class="c1">// ERROR: Undefined behavior.</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;memory&gt;
</span>
<span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LargeObject</span><span class="o">&gt;</span> <span class="n">o</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
  <span class="n">LongLivedProcessing</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">o</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So that in context of <code class="language-plaintext highlighter-rouge">Foo</code> it now owns the <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> and its underlying destructions of the dynamically allocated <code class="language-plaintext highlighter-rouge">LargeObject</code>. Once it falls out of scope, the object is dynamically deallocated. This data type is important when applying to the concept of <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> because it helps transfer ownership down stack.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LargeObject</span><span class="o">&gt;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Acts on o-&gt;x;</span>
<span class="p">}</span> <span class="c1">// o falls out of scope and it is dynamically destructed.</span>
</code></pre></div></div>

<h4 id="shared-pointer">Shared Pointer</h4>

<p>Think of shared pointer as the <code class="language-plaintext highlighter-rouge">simple_smart_pointer</code> but with the copy operation allowed and holding an internal <a href="https://en.wikipedia.org/wiki/Reference_counting">reference count</a>.</p>

<p>A crude way to represent this, ignoring operations, would be:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">simple_shared_pointer</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">simple_shared_pointer</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">simple_shared_pointer</span><span class="p">(</span><span class="k">const</span> <span class="n">simple_smart_pointer</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>    
    <span class="c1">// Increase reference count now that we have another automatically allocated instance.</span>
    <span class="o">*</span><span class="n">counter_</span> <span class="o">=</span> <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">counter_</span><span class="p">);</span>
    <span class="n">value_</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">value_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">simple_shared_pointer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">simple_smart_pointer</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Increase reference count now that we have another automatically allocated instance.</span>
    <span class="o">*</span><span class="n">counter_</span> <span class="o">=</span> <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">counter_</span><span class="p">);</span>
    <span class="n">value_</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">value_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">TArgs</span><span class="p">&gt;</span>
  <span class="k">explicit</span> <span class="n">simple_shared_pointer</span><span class="p">(...</span><span class="n">args</span><span class="p">)</span> <span class="c1">// Pass variadic args.</span>
  <span class="p">{</span>
    <span class="n">value_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">simple_shared_pointer</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// Decrease reference count now that instance is automatically deallocated.</span>
    <span class="kt">int</span> <span class="n">new_counter</span> <span class="o">=</span> <span class="o">--</span><span class="p">(</span><span class="o">*</span><span class="n">counter_</span><span class="p">);</span>
    <span class="c1">// If this is the last instance, dynamically deallocate the value.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">delete</span> <span class="n">value_</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">counter_</span><span class="p">;</span>  <span class="c1">// Reference counter.</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">value_</span><span class="p">;</span>      <span class="c1">// Shared dynamically allocated value.</span>
<span class="p">};</span>
</code></pre></div></div>

<p>An example of using a type of shared smart pointer called <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code class="language-plaintext highlighter-rouge">std::shared_ptr</code></a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">LargeObject</span><span class="o">&gt;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Do stuff with o all in scope. No passing to objects that outlive Bar.  </span>
<span class="p">}</span> <span class="c1">// Decrement reference count as std::shared_ptr is destructed.</span>

<span class="kt">void</span> <span class="nf">Baz</span><span class="p">()</span> <span class="p">{</span> 
  <span class="k">auto</span> <span class="n">o</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">LargeObject</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span> <span class="c1">// Reference count starts at 1.</span>
  <span class="n">Bar</span><span class="p">(</span><span class="n">o</span><span class="p">);</span> <span class="c1">// Increment reference count to 2 as std::shared_ptr is copied.</span>
  <span class="n">Bar</span><span class="p">(</span><span class="n">o</span><span class="p">);</span> <span class="c1">// Increment reference count to 3 as std::shared_ptr is copied.</span>
<span class="p">}</span> <span class="c1">// o falls out of scope</span>
</code></pre></div></div>

<h4 id="weak-pointer">Weak Pointer</h4>

<p>There is a similar concept in C# (i.e. <a href="https://docs.microsoft.com/en-us/dotnet/api/system.weakreference">WeakReference</a>) that corresponds to (<a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><code class="language-plaintext highlighter-rouge">std::weak_ptr</code></a> in C++. It is constructed from a <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> and [de]allocated dynamically using reference count. If the <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> is deallocated then the <code class="language-plaintext highlighter-rouge">std::weak_ptr</code> will return null.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">weak</span> <span class="o">=</span> <span class="n">shared</span><span class="p">;</span>

  <span class="c1">// Creates a std::shared_ptr pointing to std::weak_ptr with reference count 1</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shared1</span> <span class="o">=</span> <span class="n">weak</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shared2</span> <span class="o">=</span> <span class="n">weak</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// std::shared_ptr reference count 2</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shared3</span> <span class="o">=</span> <span class="n">weak</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// std::shared_ptr reference count 3</span>

  <span class="n">shared3</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>  <span class="c1">// std::shared_ptr reference count 2</span>
  <span class="n">shared2</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>  <span class="c1">// std::shared_ptr reference count 1</span>

  <span class="n">weak</span><span class="p">.</span><span class="n">expired</span><span class="p">();</span>   <span class="c1">// Check that there are still std::shared_ptr's in memory.</span>
  <span class="n">shared</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>   <span class="c1">// Only allowed if is the last std:shared_ptr</span>
  <span class="c1">// weak is expired and shared is null</span>
<span class="p">}</span>  
</code></pre></div></div>

<h2 id="examples">Examples</h2>

<p>Below are some different ways to think about how to provide your signatures and what they convey.</p>

<div class="alert alert-warning notice--warning" role="alert"><i class="fa fa-exclamation-triangle"></i> <b>WARNING:</b> Note in each section how pointer can be ambiguous and possibly result in multiple ownership. Most of the time you never really want two objects holding on to the same pointer unless they are well coordinated. If one deletes the pointer you will get a segmentation fault upon further access.</div>

<h3 id="inputs">Inputs</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>  <span class="c1">// Preferred for fundamental types as noted earlier.</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">LargeObject</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span> <span class="c1">// Read-only reference to o.</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">LargeObject</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span> <span class="c1">// Read and write reference to o.</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LargeObject</span><span class="o">&gt;</span> <span class="n">o</span><span class="p">);</span> <span class="c1">// Transfer ownership to Foo block.</span>

<span class="c1">// Copy pointer and allow read and write operations.</span>
<span class="c1">// Could be owned by caller or being passed to caller.</span>
<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">LargeObject</span><span class="o">*</span> <span class="n">o</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="outputs">Outputs</h3>

<h4 id="outputs-as-return-value">Outputs as Return Value</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">Bar</span><span class="p">();</span>  <span class="c1">// Return a copy of the function scoped return.</span>

<span class="k">const</span> <span class="kt">int</span> <span class="nf">Bar</span><span class="p">();</span> <span class="c1">// Return a read-only copy of the function scoped return.</span>

<span class="c1">// Return a reference to LargeObject held by Foo.</span>
<span class="c1">// Foo must outlive caller.</span>
<span class="n">LargeObject</span><span class="o">&amp;</span> <span class="n">Foo</span><span class="o">::</span><span class="n">Bar</span><span class="p">();</span>

<span class="c1">// Return a read-only reference to LargeObject held by Foo.</span>
<span class="c1">// Foo must outlive caller.</span>
<span class="k">const</span> <span class="n">LargeObject</span><span class="o">&amp;</span> <span class="n">Foo</span><span class="o">::</span><span class="n">Bar</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LargeObject</span><span class="o">&gt;</span> <span class="n">Bar</span><span class="p">();</span> <span class="c1">// Transfer ownership to calling block.</span>

<span class="c1">// Return a copy of a pointer.</span>
<span class="c1">// Could be owned by Foo or being passed to caller.</span>
<span class="n">LargeObject</span><span class="o">*</span> <span class="n">Foo</span><span class="o">::</span><span class="n">Bar</span><span class="p">();</span>
</code></pre></div></div>

<h4 id="outputs-as-arguments">Outputs as Arguments</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// Read and write reference to x.</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// Read and write of x from pointer.</span>
</code></pre></div></div>

<div class="alert alert-info notice--info" role="alert"><i class="fa fa-star"></i> <b>NOTE:</b> There is nothing inherently bad with having outputs as arguments but whenever possible it is better to communicate it on the return. See the Readability section below for more information and cases.</div>

<h4 id="readability">Readability</h4>

<p>In <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> there is a concept of <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a> or <a href="https://en.wikipedia.org/wiki/Functional_programming#Pure_functions">pure functions</a>, which forbids side effects. This makes programs easier to reason about because you don’t need to look at the implementation to see what they do. For example consider the signature:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoStuff</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>We can see that <code class="language-plaintext highlighter-rouge">x</code> is an input but <code class="language-plaintext highlighter-rouge">y</code> may or may not be an input or an output or both. As far as we know <code class="language-plaintext highlighter-rouge">y</code> could point to an unpopulated object that needs to be filled, or it could just be an input that is a pointer, or it could be an input transferring control of the pointer to something else (e.g. another thread or static member). Let’s narrow this and try to eliminate the ambiguity assuming that the input is a read and write value.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoStuff</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>Okay now we narrowed down the definition to allow for a variable that can be read from and written to. If we wanted to make it just a read only reference, we could <code class="language-plaintext highlighter-rouge">const</code> qualify it. Although lets assume it is read and write.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoStuff</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>While it accomplishes the same thing as the signature before, it is now very clear that the value is both read and written / computed. The signature now communicates this very cleanly and in a transparent way.  The same idea can be applied to multiple outputs too using <code class="language-plaintext highlighter-rouge">std::tuple</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">DoStuff</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>Although what do we do about <code class="language-plaintext highlighter-rouge">LargeObject</code> if we wanted to make a minor mutation, then return a copy of <code class="language-plaintext highlighter-rouge">LargeObject</code> along with the mutation?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LargeObject</span> <span class="nf">DoStuff</span><span class="p">(</span><span class="k">const</span> <span class="n">LargeObject</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span>
</code></pre></div></div>

<p>While this works from a functional point of view, it has horrible performance implications. How about:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LargeObject</span><span class="o">&amp;</span> <span class="n">DoStuff</span><span class="p">(</span><span class="k">const</span> <span class="n">LargeObject</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">o</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// Illegal</span>
</code></pre></div></div>

<p>This doesn’t work because you can’t make a <code class="language-plaintext highlighter-rouge">const</code> qualified input and be able to return a read/write reference to it. Although this will work:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LargeObject</span><span class="o">&amp;</span> <span class="n">DoStuff</span><span class="p">(</span><span class="n">LargeObject</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span>
</code></pre></div></div>

<p>Isn’t this the same thing as just returning a <code class="language-plaintext highlighter-rouge">void</code>? Yes, and maybe it is best just to do so since <code class="language-plaintext highlighter-rouge">&amp;</code> without <code class="language-plaintext highlighter-rouge">const</code> communicates that it is possibly read and definitely written. In these cases, it is hard to express the semantics cleanly due to performance.</p>

<h3 id="dependency-injection-di-container">Dependency Injection (DI) Container</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Component1</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">Component1</span><span class="p">(</span><span class="kt">bool</span> <span class="n">production</span><span class="p">)</span> <span class="o">:</span> <span class="n">production_</span><span class="p">(</span><span class="n">production</span><span class="p">)</span> <span class="p">{}</span>
  <span class="c1">// ...</span>
 <span class="nl">private:</span>
  <span class="c1">// ...</span>
  <span class="kt">bool</span> <span class="n">production_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Component2</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">Component2</span><span class="p">(</span><span class="kt">bool</span> <span class="n">production</span><span class="p">)</span> <span class="o">:</span> <span class="n">production_</span><span class="p">(</span><span class="n">production</span><span class="p">)</span> <span class="p">{}</span>
  <span class="c1">// ...</span>
 <span class="nl">private:</span>
  <span class="c1">// ...</span>
  <span class="kt">bool</span> <span class="n">production_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// Consume only unique pointers since no other object should hold the dependencies</span>
  <span class="k">explicit</span> <span class="n">Container</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Component1</span><span class="o">&gt;</span> <span class="n">component1</span><span class="p">,</span> 
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Component2</span><span class="o">&gt;</span> <span class="n">component2</span><span class="p">)</span>
    <span class="c1">// Release ownership to the new Container.</span>
    <span class="o">:</span> <span class="n">component1_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">component1</span><span class="p">)),</span> 
      <span class="n">component2_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">component2</span><span class="p">))</span> <span class="p">{}</span>

  <span class="k">static</span> <span class="n">Container</span> <span class="n">CreateNonProd</span><span class="p">()</span> <span class="p">{</span>    
    <span class="k">return</span> <span class="n">Container</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Component1</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*production=*/</span><span class="nb">false</span><span class="p">),</span>
      <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Component2</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*production=*/</span><span class="nb">false</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">static</span> <span class="n">Container</span> <span class="n">CreateProd</span><span class="p">()</span> <span class="p">{</span>    
    <span class="k">return</span> <span class="n">Container</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Component1</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*production=*/</span><span class="nb">true</span><span class="p">),</span>
      <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Component2</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*production=*/</span><span class="nb">true</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// Never expose the pointer, just the value pointed to.</span>
  <span class="n">Component1</span><span class="o">&amp;</span> <span class="n">component1</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">component1_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">Component2</span><span class="o">&amp;</span> <span class="n">component2</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">component2_</span><span class="p">;</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Component1</span><span class="o">&gt;</span> <span class="n">component1_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Component2</span><span class="o">&gt;</span> <span class="n">component2_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">DoStuff</span><span class="p">(</span><span class="n">Component1</span><span class="o">&amp;</span> <span class="n">component</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">prod_container</span> <span class="o">=</span> <span class="n">Container</span><span class="o">::</span><span class="n">CreateProd</span><span class="p">();</span>
  <span class="n">DoStuff</span><span class="p">(</span><span class="n">prod_container</span><span class="p">.</span><span class="n">component1</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="rules-of-thumb">Rules of Thumb</h2>

<ul>
  <li>Copies can be a faster operation for small objects.</li>
  <li>Only use smart pointers when the object is very large or needs to be shared outside the scope it was created in.</li>
  <li>Avoid raw pointers whenever possible.</li>
  <li>Prefer references over raw or smart pointers where available.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Hopefully this gives you a sense now how storage works and how to communicate memory semantics in the best and most performant way possible. Please feel free to leave comments on errata or your own thoughts.</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#c" class="page__taxonomy-item" rel="tag">C++</a>
    
    </span>
  </p>




        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-10-15T00:00:00-07:00">October 15, 2020</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=C%2B%2B+Memory+Semantics+for+C%23+and+Java+Devs%20http%3A%2F%2Flocalhost%3A4000%2Fcpp-memory-semantic-for-csharp-java-devs%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fcpp-memory-semantic-for-csharp-java-devs%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fcpp-memory-semantic-for-csharp-java-devs%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/streaming-uuencoder-in-net/" class="pagination--pager" title="Streaming UUEncoder in .NET.
">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/streaming-uuencoder-in-net/" rel="permalink">Streaming UUEncoder in .NET.
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Flashback

</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/get-windows-service-name-from/" rel="permalink">Get Windows Service name from executable in PowerShell.
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          less than 1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">I was recently putting some PowerShell scripts together for deployment
and maintenance of software to our machine instances. One of the
requirements was to b...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/log-per-class-pattern/" rel="permalink">Log per class pattern.
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Rookie Moves

</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/creating-xml-based-templates-in-log4net/" rel="permalink">Creating XML based templates in log4net.
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          3 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Motivation

</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="mailto:awalsh128@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> Email</a></li>
        
      
        
          <li><a href="https://github.com/awalsh128" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/andrew-walsh-a235787/" rel="nofollow noopener noreferrer"><i class="fab fa-linkedin" aria-hidden="true"></i> Linkedin</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 Andrew Walsh. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <script>
    var disqus_config = function () {
      this.page.url = "http://localhost:4000/cpp-memory-semantic-for-csharp-java-devs/";  /* Replace PAGE_URL with your page's canonical URL variable */
      this.page.identifier = "/cpp-memory-semantic-for-csharp-java-devs"; /* Replace PAGE_IDENTIFIER with your page's unique identifier variable */
    };
    (function() { /* DON'T EDIT BELOW THIS LINE */
      var d = document, s = d.createElement('script');
      s.src = 'https://andrew-walshs-website.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  </body>
</html>
